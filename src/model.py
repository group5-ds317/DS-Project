# -*- coding: utf-8 -*-
"""Baseline 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11UXfxyDTrSpMkuMzLllU86yOVHlaGT1j
"""

import numpy as np
import pandas as pd
import math

from sklearn.preprocessing import normalize
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer

processed_student = pd.read_excel('/content/drive/MyDrive/Nhóm 5 - DS317.P11/Đồ án mô học/Dataset/Processed/Processed Data With Raw Data/processed_student.xlsx', index_col=0)
processed_course = pd.read_excel('/content/drive/MyDrive/Nhóm 5 - DS317.P11/Đồ án mô học/Dataset/Processed/Processed Data With Raw Data/processed_course.xlsx', index_col=0)
processed_score = pd.read_excel('/content/drive/MyDrive/Nhóm 5 - DS317.P11/Đồ án mô học/Dataset/Processed/Processed Data With Raw Data/processed_score.xlsx', index_col=0)
subject_popularity = pd.read_excel('/content/drive/MyDrive/Nhóm 5 - DS317.P11/Đồ án mô học/Dataset/Processed/Processed Data With Raw Data/subject_popularity.xlsx', index_col = 0)
group_sum_course = pd.read_excel('/content/drive/MyDrive/Nhóm 5 - DS317.P11/Đồ án mô học/Dataset/Processed/Processed Data With Raw Data/group_sum_course.xlsx')

class Model():
    def __init__(self, student_df, score_df, course_df, subject_popularity_df, group_sum_course):
        self.student = student_df
        self.score = score_df
        self.course = course_df
        self.subject = subject_popularity_df
        self.group_sum_course = group_sum_course

    def get_group_sum_course(self, faculty: str, year: int, term: int) -> pd.DataFrame:
      group_course_result = self.group_sum_course.loc[(self.group_sum_course['khoa'] == faculty) & (self.group_sum_course['namhoc'] < year) & (self.group_sum_course['sohocky'] == term - 1), :]
      group_course_result = group_course_result[['khoa', 'somonhoc']]
      group_course_result = group_course_result.groupby('khoa').mean()
      group_course_result['somonhoc'] = group_course_result['somonhoc'].apply(lambda x: math.ceil(x))
      group_course_result = group_course_result.reset_index()
      return group_course_result.iloc[0]['somonhoc']

    def get_subject_popularity(self, mssv: str, top_m: int, current_term: int, attended_courses: list[str]) -> np.array:
        student_info = self.student[self.student['mssv'] == mssv].iloc[0]
        faculty = student_info['khoa']
        start_year = student_info['namhoc_batdau']

        target_year = start_year + (current_term - 1) // 2
        target_term = (current_term - 1) % 2 + 1
        faculty_courses = self.subject[self.subject['khoa'] == faculty]
        previous_courses = faculty_courses[
            (faculty_courses['namhoc'] < target_year) |
            ((faculty_courses['namhoc'] == target_year) & (faculty_courses['sohocky'] < target_term))
        ]
        previous_courses = previous_courses.sort_values(by=['dophobien_scaled'], ascending=False)
        previous_courses = previous_courses.drop_duplicates(subset=['mamh'], keep='first')
        previous_courses = previous_courses[~previous_courses['mamh'].isin(attended_courses)]
        top_courses = previous_courses.nlargest(top_m, 'sosv')['mamh']
        return top_courses.values

    def get_failed_courses(self, mssv: str, term: int) -> np.array:
        failed_courses = self.score[
            (self.score['mssv'] == mssv) &
            (self.score['diem'] < 5) &
            (self.score['sohocky'] == term - 1)
        ]['mamh'].unique()
        return failed_courses

    def get_attended_courses(self, mssv: str, term: int) -> np.array:
        attended_courses = self.score[
            (self.score['mssv'] == mssv) &
            (self.score['sohocky'] == term - 1)
        ]['mamh'].unique()
        return attended_courses

    def get_all_attended_courses(self, mssv: str, term: int) -> np.array:
        attended_courses = self.score[
            (self.score['mssv'] == mssv) &
            (self.score['sohocky'] < term)
        ]['mamh'].unique()
        return attended_courses

    def combined_feature(self, courses: np.array) -> list:
        course_texts = self.course[self.course['mamh'].isin(courses)].apply(
            lambda row: f"{row['mamh']} {row['nganhmh']} {row['loaimh']} {row['nhomloaimh']}", axis=1
        ).tolist()
        return course_texts

    def aggregate_cosine_sim(self, cosine_sim_matrix: pd.DataFrame, type: str) -> pd.DataFrame:
      if type == 'max':
        return cosine_sim_matrix.max(axis=1)
      elif type == 'min':
        return cosine_sim_matrix.min(axis=1)
      elif type == 'mean':
        return cosine_sim_matrix.mean(axis=1)
      elif type == 'sum':
        return cosine_sim_matrix.sum(axis=1)

    def recommend(self, mssv: str, term: int, pooling: str, top_m: int) -> pd.DataFrame:
        faculty = self.student[self.student['mssv'] == mssv]['khoa'].values[0]
        faculty = faculty.strip()
        year = int(self.score[(self.score['mssv'] == mssv) & (self.score['sohocky'] == term)]['namhoc'].values[0])

        all_attended_courses = self.get_all_attended_courses(mssv, term)
        attended_courses = self.get_attended_courses(mssv, term)
        failed_courses = self.get_failed_courses(mssv, term)

        popular_courses = self.get_subject_popularity(mssv, top_m, term, all_attended_courses)

        recommended_courses = np.setdiff1d(popular_courses, all_attended_courses)
        recommended_courses = np.unique(np.concatenate((recommended_courses, failed_courses)))

        all_courses = np.concatenate((attended_courses, recommended_courses))
        course_texts = self.combined_feature(all_courses)

        vectorizer = TfidfVectorizer()
        vectorizer.fit(course_texts)

        attended_vectors = vectorizer.transform(self.combined_feature(attended_courses))
        recommended_vectors = vectorizer.transform(self.combined_feature(recommended_courses))

        cosine_sim_matrix = cosine_similarity(recommended_vectors, attended_vectors)
        cosine_sim_matrix_df = pd.DataFrame(cosine_sim_matrix, index=recommended_courses, columns=attended_courses)

        top_n = self.get_group_sum_course(faculty, year, term)
        top_recommended = self.aggregate_cosine_sim(cosine_sim_matrix_df, pooling).nlargest(int(top_n))

        return top_recommended.reset_index().rename(columns={'index': 'mamh', 0: 'similarity_score'})

    def evaluate(self, mssv: str, term: int, pooling: str, top_m: int) -> float:
        recommended_courses = self.recommend(mssv, term, pooling, top_m)['mamh']
        actual_courses = self.score[(self.score['mssv'] == mssv) & (self.score['sohocky'] == term)]['mamh'].unique()

        true_positive_count = recommended_courses.isin(actual_courses).sum()
        precision = true_positive_count / len(recommended_courses) if len(recommended_courses) > 0 else 0
        recall = true_positive_count / len(actual_courses) if len(actual_courses) > 0 else 0
        f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

        return precision, recall, f1_score
